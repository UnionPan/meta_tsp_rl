# -*- coding: utf-8 -*-

import traci
import sumo
import net.pathfinder_edge
from net.flow_generator import SumoNet
from net.pathfinder_edge import PathFinder
import sumolib
import pickle
from net.pathfinder_lane import LanePathFinder

class Args:
    def __init__(self):
        self.UP_VSL_NUM = 2
        self.DOWN_VSL_NUM = 1
        self.DIST = 1000
        self.BUFFER_LEN = 200
        self.SIGHT_DIST = 100

args = Args()

class VSLControllerGenerator(SumoNet):
    
    ''' the logics of the VSL controller generated by this class are that 
        1) vehicles change their speed limit when seeing the speed limit sign 
        2) A vehicle enters a sight distance zone = it sees the speed limit sign
        3) A vehicle enters a buffer zone = it recovers the original speed
    
    '''
    
    def __init__(self, subpath="/turnpike/turnpike.single.net.xml"):
        super().__init__(sumo.WORK_PATH + subpath)
        self.subpath = subpath
        self.path = sumo.WORK_PATH + subpath
        self.get_edges_info()
        self.get_nodes_info_from_edges()
        self.pathfinder = PathFinder(self.edges_info, self.nodes_info)
        self.lpf = LanePathFinder(self.path)
        
    def _find_onramps(self):
        ''' 
        browse through the networks to find junctions that have at least 2 'from' edges 
        '''
        _onramps = []
        for node in self.nodes_info:
            len_in = len(self.nodes_info[node]['in'])
            if len_in > 1:
                _onramps.append(node)
        self._onramps = _onramps
        return self._onramps
        
    def _get_road_type(self, junction, edge):
        '''
        check if the edge of a junction is main road
        '''
        if self.edges_info[edge]["no.lanes"] > 2:
            if edge in self.nodes_info[junction]['in']:
                return 'upstream'
            elif edge in self.nodes_info[junction]['out']:
                return 'downstream'
    
    def _get_length(self, edge):
        return list(self.edges_info[edge]['lanes'].values())[0]['length']
    
    
    def get_controller_locations(self):
        ControlPoints = []
        RecoveryPoints = []
        self._find_onramps()
        for _junc in self._onramps:
            for edge in self.nodes_info[_junc]['out']:
                ''' if no.lane > 2, it's on the main road '''
                if self.edges_info[edge]["no.lanes"] < 3:
                    continue
                startpoint = tuple([edge, 0])
                ''' find controlpoints every 1000 m downstream/upstream section; 
                find the recovery point at the end of the last downstream control zone 
                '''
                self. _search_next_upstream_checkpoint(startpoint, 0, ControlPoints)
                self. _search_next_downstream_checkpoint(startpoint, 0, ControlPoints, RecoveryPoints)
        self.ControlPoints = ControlPoints
        self.RecoveryPoints = RecoveryPoints
        ControlKeys = ["C"+"{0:03}".format(i) for i in range(len(ControlPoints))]
        RecoveryKeys = ["R"+"{0:03}".format(i) for i in range(len(RecoveryPoints))]
        C_Dict = dict(zip(ControlKeys, ControlPoints))
        R_Dict = dict(zip(RecoveryKeys, RecoveryPoints))
        E2Dict, E2Ref = self.getE2Dicts(C_Dict, R_Dict)
        return ControlPoints, RecoveryPoints, E2Dict, E2Ref
                
    def no_ramp_in_path(self, Paths):
        _Paths = []
        for path in Paths:
            pass_path = 0
            for link in path:
                if self.edges_info[link[0]]['no.lanes'] < 3:
                    pass_path = 1
                    continue
            if pass_path:
                continue
            _Paths.append(path)
        return _Paths                

        
    def _find_up_checkpoints(self, checkpoint, dist):
        ''' checkpoint: tuple(name_of_edge, pos_on_edge) 
            dist: float, distance to search upstream
        '''
        Paths =  self.pathfinder.get_upstream_paths(checkpoint[0], dist, checkpoint[1])
        Paths = self.no_ramp_in_path(Paths)
        return [ tuple([Paths[k][-1][0], Paths[k][-1][2]]) for k in range(len(Paths)) ]

            
    def _find_down_checkpoints(self, checkpoint, dist):
        ''' checkpoint: tuple(name_of_edge, pos_on_edge) 
            dist: float, distance to search upstream
        '''
        Paths =  self.pathfinder.get_downstream_paths(checkpoint[0], dist, checkpoint[1])
        Paths = self.no_ramp_in_path(Paths)
        return [ tuple([Paths[k][-1][0], Paths[k][-1][2]]) for k in range(len(Paths)) ]
        
    def _search_next_upstream_checkpoint(self, checkpoint, count, ControlPoints, dist=args.DIST):
        _count = count + 1
        if _count <= args.UP_VSL_NUM:
            nextCheckpoints = self._find_up_checkpoints(checkpoint, dist)
            for _nextcheckpoint in nextCheckpoints:
                ControlPoints.append(_nextcheckpoint)
                self._search_next_upstream_checkpoint(_nextcheckpoint, _count, ControlPoints, dist)
                
    def _search_next_downstream_checkpoint(self, checkpoint, count, ControlPoints, RecoveryPoints, dist=args.DIST):
        _count = count + 1
        if _count <= args.DOWN_VSL_NUM:
            nextCheckpoints = self._find_down_checkpoints(checkpoint, dist)
            for _nextcheckpoint in nextCheckpoints:
                ControlPoints.append(checkpoint)
                self._search_next_downstream_checkpoint(_nextcheckpoint, _count, ControlPoints, RecoveryPoints, dist)
        else:
            RecoveryPoints.append(checkpoint)

    def fillE2Info(self, e2id, Dict, e2Dict, e2ref):
        c_lanepos = Dict[e2id]
        upCheckpoints = self._find_up_checkpoints(c_lanepos, dist=50)
        sub_id = 0
        for e2_startedge, e2_pos in upCheckpoints:
            ''' get all e2 coverage paths '''
            for e2_startlane in self.lpf.net.getEdge(e2_startedge).getLanes():
                e2_startlane = e2_startlane.getID()
                e2LanePaths = self.lpf.getLanePath(e2_startlane, 100, e2_pos, 'down')
                
                for _e2path in e2LanePaths:
                    _info = {
                        'lanes': list(_e2path.keys()),
                        'pos': e2_pos,
                        'endPos': list(_e2path.values())[-1][1]
                        }
                    e2Dict[e2id+'_'+str(sub_id)] = _info
                    e2ref[e2id].append(e2id+'_'+str(sub_id))
                    sub_id += 1


    def getE2Dicts(self, cDict, rDict):
        ControlDict = {}
        RecoveryDict = {}
        e2Dict = {}
        lpf = LanePathFinder(self.path)
        e2ref = {}
        ''' fill control area information needed to build e2 detectors '''
        for control_id in cDict:
            e2ref[control_id] = []
            self.fillE2Info(control_id, cDict, e2Dict, e2ref)
        for recovery_id in rDict:
            e2ref[recovery_id] = []
            self.fillE2Info(recovery_id, rDict, e2Dict, e2ref)
        self.e2Dict = e2Dict
        self.e2ref = e2ref
        return e2Dict, e2ref          
            
        
    
    def write_points_as_e2(self, to_file=sumo.WORK_PATH+"/turnpike/turnpike.single.E2asControlRecoveryPoints.additional.xml"):
        optParser = sumolib.options.ArgumentParser()
        options = optParser.parse_args()
        options.routefile = to_file
        with open(options.routefile, 'w') as vslfile:
            vslfile.write('<additional>\n')
            for e2_id in self.e2Dict:
                e2Info = self.e2Dict[e2_id]
                lanes = e2Info['lanes']
                pos = e2Info['pos']
                endPos = e2Info['endPos']
                vslfile.write(('    <laneAreaDetector id="%s" lanes="') % (e2_id))
                for i_, l_ in enumerate(lanes):
                    vslfile.write(('%s') % (l_))
                    if i_ < len(lanes)-1:
                        vslfile.write(" ")
                vslfile.write(('" pos="%s" endPos="%s" freq="900" file="%s"/>\n' )%(str(pos), str(endPos), "turnpike.w_detectors.net.test.xml" ))
                
            vslfile.write('</additional>\n')
                
                
    # def write_controlzones_as_additional(self, to_file=sumo.WORK_PATH+"/turnpike/turnpike.single.E2asDetectors.additional.xml"):
        
        

    #     optParser = sumolib.options.ArgumentParser()
    #     options = optParser.parse_args()
    #     options.routefile = to_file

    #     with open(options.routefile, 'w') as vslfile:
    #         vslfile.write('<additional>\n')
    #         for path_ in self.Visions:
    #             _entry = tuple([path_[0][0], path_[0][1]])

    #             edge = loc_[0]
    #             pos_ = loc_[1]
    #             for lane_index in self.edges_info[edge]['lanes']:
    #                 laneid = edge + "_" + str(lane_index)
    #                 vslfile.write(('    <entryExitDetector id="%s" lane="%s" pos="%s" freq="900" file="%s"/>\n' ) %
    #                                ('speedlimit'+str(_c), str(laneid), str(pos_), ("turnpike.w_detectors.net.test.xml")))
    #                 _c += 1
    #         vslfile.write('</additional>\n')

    
if __name__ == '__main__':
   
    vsl = VSLControllerGenerator()
    juncs = vsl._find_onramps()
    nodesInfo = vsl.nodes_info
    edgesInfo = vsl.edges_info
    ControlPoints, RecoveryPoints, E2Dict, E2Ref = vsl.get_controller_locations()
    
    pickle.dump([E2Dict, E2Ref], open(sumo.WORK_PATH + "/turnpike/vsl2.0", 'wb'))
    
    vsl._find_up_checkpoints(['38913001#1.26', 0], 100)
    vsl.write_points_as_e2()
    
    
    # net.getEdge(edgeID).getLaneNumber()
    
    # vsl.write_controlzones_as_additional()

    # pickle.dump(VisionZones, open(sumo.WORK_PATH + "/turnpike/turnpike_vision_zones", 'wb'))
    # pickle.dump(BufferZones, open(sumo.WORK_PATH + "/turnpike/turnpike_buffer_zones", 'wb'))
    
    
    # PathsOfSight = vsl._find_up_checkpoints(('38913001#1.26',0), args.SIGHT_DIST)
    # PathsOfSight_ = vsl.no_ramp_in_path(PathsOfSight)
